<!--CPU CLASS-->
CPU<br><br>

Variables: <br><br>

Methods: <br><br>
# @pre --> AI mode is activated, player selected level of difficulty<br>
# @param --> AI mode difficulty<br>
# @post --> AI mode is initialized<br>
# @return --> none<br>
def __init__(self, difficulty)<br><br>

# @pre - AI mode is activated<br>
# @param --> none<br>
# @post --> AI ships placed on game board<br>
# @return --> none<br>
def place_ship(self)<br><br>

# @pre --> AI mode is activated<br>
# @param --> first hit, last hit<br>
# @post --> the direction of medium hit is set<br>
# @return --> direction of ship <br>
def find_direction(self,first_hit,last_hit)<br><br>

# @pre --> AI mode is activated<br>
# @param --> hit/miss, row, column, is destroyed (true false)<br>
# @post --> Update the player on AI status <br>
# @return --> none<br>
def CPU_update(self, hm, row, col, is_destroyed)<br><br>

# @pre --> AI mode is activated, player selected level of difficulty<br>
# @param --> self<br>
# @post --> AI fires at the player's board<br>
# @return --> the location of where the cpu will fire at<br>
def easy_AI(self)<br><br>

# @pre --> AI mode is activated, player selected level of difficulty<br>
# @param --> self<br>
# @post --> AI fires at the player's board<br>
# @return --> the location of where cpu will fire at<br>
def mid_AI(self)<br><br>

# @pre --> AI mode is activated, player selected level of difficulty<br>
# @param --> self<br>
# @post --> AI fires at the player's board<br>
# @return --> none<br>
def hard_AI(self)<br><br>

# @pre --> AI mode is activated<br>
# @param --> self<br>
# @post --> <br>
# @return --> <br>
def take_shot(self)<br><br><br><br>


<!--POWER CLASS-->
POWER<br><br>

Variables: <br><br>

Methods: <br><br>
# @pre -- >Difficulty selected.<br>
# @param --> row, column, level of difficulty (easy = 1, medium = 2, hard = 3)<br>
# @post --> None<br>
# @return --> None<br>
def __init__(self, row, col, difficulty)<br><br>

# @pre --> Power-up active.<br>
# @param --> clicked_row, clicked_column are the squares the user chooses.<br>
# @post --> None<br>
# @return --> A list of tuples indicating where the power-up lets the user hits.<br>
def squares(self, clicked_row, clicked_col)<br><br>

# @pre --> Power-up active.<br>
# @param --> clicked_row, clicked_column are the squares the user chooses.<br>
# @post --> None<br>
# @return --> A list of tuples indicating where the power-up lets the user hits.<br>
def easy_squares(self, clicked_row, clicked_col)<br><br>

# @pre --> Power-up active.<br>
# @param  --> clicked_row, clicked_column are the squares the user chooses.<br>
# @post --> None<br>
# @return --> A list of tuples indicating where the power-up lets the user hits.<br>
def medium_squares(self, clicked_row, clicked_col)<br><br>

# @pre --> Power-up active.<br>
# @param --> clicked_row, clicked_column are the squares the user chooses.<br>
# @post --> None<br>
# @return --> A list of tuples indicating where the power-up lets the user hits.<br>
def hard_squares(self, clicked_row, clicked_col)<br><br>

# @pre --> Power-up active.<br>
# @param --><br>
# @post --> None<br>
# @return --><br>
def trimmed_list(self, square_list)<br><br><br>


<!--SHIP CLASS-->
SHIP<br><br>

Variables: <br><br>
self.locations #list of lists containing (row, col, hit(boolean)) for each ship spot<br>
self.start_r #stores start row<br>
self.start_c #stores start column<br>
self.end_r #stores end row<br>
self.end_c #stores end column<br>
self.destroyed #boolean for ship destroyed or not<br><br><br>

Methods: <br><br>
#@pre --> initialize ship object<br>
#@param --> passed starting row and column, ending row and column<br>
#@post --> no return<br>
__init__(self, start_r, start_c, end_r, end_c)<br><br>

#@pre --> draw the ship on the appropriate board<br>
#@param --> passed which board it belongs on, drawing surface<br>
#@post --> no return<br>
draw(self,right,win)<br><br>

#@pre --> marks ship segment as hit<br>
#@param --> passed row and column to change<br>
#@post --> no return<br>
mark_hit(self, row, col)<br><br>

#@pre --> returns the x,y coordinates of the ship's center<br>
#@param --> no passed variables<br>
#@post --> returns x, y coordinates<br>
get_x_y(self)<br><br>

#@pre --> determines if the ship is destroyed<br>
#@param --> no passed variables<br>
#@post --> returns true if ship is destroyed, false otherwise<br>
is_destroyed(self)<br><br><br>


<!--BOARD CLASS-->
BOARD<br><br>

Variables: <br><br>
self.player0ships #stores player 0 ships<br>
self.player1ships #stores player 1 ships<br>
self.player_ships #stores player0ships and player1ships<br>
self.win #stores drawing surface<br>
self.player0_hits_misses #stores player 0 shots<br>
self.player1_hits_misses #stores player 1 shots<br>
self.player_hits_misses #stores player 1 and player 0 shot arrays<br><br><br>

Methods:<br><br>
#@pre --> initialize board object<br>
#@param --> passed player 0 and player 1 ships, drawing surface<br>
#@post --> returns true if ship is destroyed, false otherwise<br>
__init__(self, win, player0ships, player1ships)<br><br>

#@pre --> initialize player shot variables<br>
#@param --> no passed variables<br>
#@post --> no return<br>
initialize_hits_misses(self)<br><br>

#@pre --> draw the board background<br>
#@param --> no passed variables<br>
#@post --> no return<br>
draw_background(self)<br><br>

#@pre --> draw the grid on the board<br>
#@param --> no passed variables<br>
#@post --> no return<br>
draw_grid(self)<br><br>

#@pre --> draw the complete board for respective player<br>
#@param --> passed player to draw board for<br>
#@post --> no return<br>
draw(self, player)<br><br>

#@pre --> determine if attack was a hit or miss<br>
#@param --> passed attacking player, attack row and column<br>
#@post --> return true if hit, false otherwise<br>
hit_ship(self, player, row, col)<br><br>

#@pre --> update board window<br>
#@param --> passed player to draw board for<br>
#@post --> no return<br>
update(self, player)<br><br>

#@pre --> print player ships, hits and misses<br>
#@param --> no passed variables<br>
#@post --> no return<br>
info(self)<br><br><br>


<!--GAME CLASS-->
GAME<br><br>
Variables<br><br><br>
self.board #stores a Board object <br>
self.player_turn #stores current player turn <br>
self.player_0_ships, self.player_1_ships #store array of Ship objects <br>
self.win #pygame window <br><br>
Methods<br><br><br>
    #@pre - initialize Game Class<br>
    #@param - passed Pygame window and arrays of ships for players 1 and 2<br>
    #@post - Creates a Board class. Stores the current player's turn<br>
    #@return - None<br>
    def __init__(self, win, p0ships, p1ships):<br><br>
	
	#@pre - Checks for a hit in the Board class on the opposing player's ship<br>
    #@param - passed row and col of attempted hit<br>
    #@post - updates data structures in Board class and any hit Ship<br>
    #@return - None<br>
    def hit_ship(self, row, col):<br><br>
	
	#@pre - Prints the result of an attempted hit or miss<br>
    #@param - passed a Ship object or 0<br>
    #@post - prints result of attempt to User<br>
    #@return - None<br>
    def print_hit(self, ship):<br><br>
	
	#@pre - Updates the output to the screen<br>
    #@param - None<br>
    #@post - prints the grids and ships of the window<br> 
    #@return - None<br>
    def update(self):<br><br>
	
	#@pre - will print to the players to switch users <br>
    #@param - None<br>
    #@post - Prints to the board "Switching player in 2 seconds" <br>
    #@return - None <br>
    def switch_players(self):<br><br>
	
	#@pre - Changes the player_turn<br>
    #@param - None<br>
    #@post - self.player_turn is reversed<br>
    #@return - None<br>
    def change_turn(self):<br><br>
	
	#@pre - determines if the game should be over<br>
    #@param - None<br>
    #@post - causes game to end if one of the players has 0 ships left<br>
    #@return - True or False<br>
    def game_over(self):<br><br>
	
    #@pre - If the mouse is on the left grid, it will show to the user which row and col is currently selected<br>
    #@param - None<br>
    #@post - draws a green circle in the middle of a box if the mouse is on the grid<br>
    #@return - None<br>
    def hover(self):<br><br>
	
    #@pre - uses the pixel position in x and y to get the row and column on the left grid<br>
    #@param - passed pos (x,y)<br>
    #@post - gives corresponding row and column to the hover() method<br>
    #@return - row, col<br>
    def get_row_col_from_pos(self, pos):<br><br>
	
    #@pre - if the mouse makes a click in a relevant position(on the left grid), then it attepts a hit<br>
    #@param - pos (x,y) in pixels<br>
    #@post - if the position is valid, then it will attempt a hit and then change players<br>
    #@return - None<br>
    def select(self, pos):<br><br><br>


<!--Initialize-->
INITIALIZE<br><br>

Variables<br><br><br>
self.gameSizeSelected #determines if the number of ships needs to be selected<br>
self.win #contains pygame window<br>
self.shipsSelected #number of ships to be picked<br>
self.shipList #contains array of Ship objects<br>
self.b1-b6 #Button objects <br>
self.placed1-placed6 #booleans for if ship is placed <br>
self.s1-s6 # buttons for actual Ship location placement <br>
self.shipArray # 10x10 grid for placement of ships<br><br>

Methods<br><br><br>
#@pre - needs a game size if choose gamesize is false<br>
#@param - the window/surface, a boolean of whether the gamesize is already decided and a game size that only matters if choosegamesize is false<br> 
#@post - defines variables and either calls gameSize() or skips to pickShips()<br>
#@return - none<br>
def __init__(self, win, ChooseGameSize, GameSize):<br><br>

#@pre - none<br>    
#@param - none<br>         
#@post - draws the first set of buttons to determine ship count and checks when theyve been clicked<br>
#@return - none<br>                          
def gameSize(self):<br><br>

#@pre - needs to have the amount of ships already decided<br>
#@param - amount of ships in the game<br>         
#@post - clears the window then draws the correct amount of buttons then when a button is selected calls the place ship function and grays-out and disables the button until all buttons have been selected<br>
#@return - none<br>
def pickShips (self, shipCount):<br><br>

#@pre - needs a ship to have already been selected<br>
#@param - ship length  <br>       
#@post - continuously draws a the ship on the cursor and the ship buttons and allows the user to rotate it until a valid position is clicked on<br>
#@return - none<br>
def placeShip (self, shipNum):<br><br>

#@pre - requires that the board is drawn correctly<br>
#@param - mouse position, a boolean of whether the ship is placed vertically and the size of the specific ship<br>        
#@post - using the parameters given, this function decides if the user can place a piece there<br>
#@return - boolean of whether location is valid<br>
def isValid(self,pos, vertical, shipNum):<br><br>

#@pre - needs window to be defined <br>
#@param - none<br>        
#@post - Redraws the screen starting with a black fill, then the text, grid, then the ships on the board<br>
#@return - none<br>
def drawPlayerBoard (self):<br><br>

#@pre - needs a list of ships<br>
#@param - no param<br>        
#@post - returns the array of ship objects<br>
#@return - Returns list of ships<br>
def returnShip(self):<br><br><br>


<!--Button-->
BUTTON<br><br>

Variables: <br><br><br>
self.color # contains the color of the button <br>
self.x #contains x coordinate(in pixels) <br>
self.y # contains y coordinate(in pixels) <br>
self.width #width <br>
self.height #height <br>
self.text #text in button <br><br>

Methods: <br><br><br>
#@pre - none<br>
#@param - color of button, position, deminsions and text  <br>      
#@post - defines the passed in variables<br>
#@return - none<br>
def __init__(self, color, x, y, width, height, text=''):<br><br>

#@pre - the button needs to be defined <br> 
#@param - window to draw on <br>
#@post - draws the button<br>
#@return - none<br>
def draw(self, win):<br><br>

#@pre - button needs to be defined<br>
#@param - position of mouse<br>        
#@post - checks if mouse is over button<br>
#@return - boolean of whether over position<br>
def hover(self, pos):<br><br><br>


<!--MAIN CLASS-->
MAIN<br><br><br>
Main Method:<br><br>
#@pre --> loops, looks for events in game<br>
#@post --> no return<br>
main()<br><br>

#@pre - will print to the screen the winner of the game if the proper stipulations are met<br><br>
#@param - Game class<br>
#@post - prints to the screen the winner and ends the game<br>
#@return - None<br>
def winner(game):<br><br><br><br>

